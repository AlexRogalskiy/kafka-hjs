= Apache Kafka: *что это и как она изменит архитектуру* *вашего приложения*
Иван Пономарёв, КУРС/МФТИ
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900


//== Часть 1. Введение
:!figure-caption:

ponomarev@corchestra.ru

icon:twitter[size=lg] @inponomarev

[%notitle]
== Кто я такой

[cols="40a,60a"]
|===
.^|image::me.jpg[]
.^|[.arrov_bottom]
* Tech Lead at KURS
* ERP systems & Java background
* Speaker at JPoint, Devoops, Heisenbug, JUG.MSK, etc.
* Twitter @inponomarev
|===

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
1. *Что такое лог и почему это важно*
2. Что такое Kafka и что она умеет
3. Что такое потоковая архитектура и на что способны потоковые обработчики
4. Kafka и JavaScript
5. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Что такое лог?

image::not_brand/oak-log.jpg[{image-30-width}]

[%step]
* Добавляем данные в конец
* Записанное не можем изменить
* Читаем последовательно

== -- Что наша жизнь?


== -- Что наша жизнь?

image::not_brand/oak-log.jpg[{image-40-width}]

-- *Лог!*



== Автоматизировать склад. Как?

[.fragment]
[cols="1,1,1",options=header]
|===
|товар | ячейка | кол-во 
|X     |  A     | 8     
|X     |  B     | 2      
|Y     |  B     | 1      
|===

// База данных -- это склад?!

== Всё хорошо, пока...

// Надо взять товар с полки, но там пусто!

image::not_brand/emptyshelf.jpg[{image-50-width}]

== Что это может быть?

[cols=2]
|===
a|
[%step]
* Украли (разбили, выкинули и т. п.)
* Потеряли: лежит где-то рядом
a|
|===

== Что это может быть?

[cols=2]
|===
a|
* Украли (разбили, выкинули и т. п.)
* Потеряли: лежит где-то рядом
* *ЭТО ВАША ТУПАЯ ПРОГРАММА НЕ РАБОТАЕТ*
a|
image::not_brand/upset-cropped.jpg[]

|===

== Что будем делать?

// * «Текущий снимок»? Делать нечего.
// * «База данных есть склад» -- просто, но не работает

image::not_brand/messy.jpg[{image-50-width}]


== Как на самом деле надо проектировать?

[cols="1a,3a"]
|===
|image::noway.png[]
<.^|* «База данных -- это склад»
|===

== Как на самом деле надо проектировать?

[cols="1a,3a"]
|===
|image::noway.png[]
<.^|* «База данных -- это склад»
|image::okay.png[]
<.^|

* База данных отражает процессы. 

* Текущее состояние -- результат выполнения процессов
|===


== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|===

== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|09.04.2020|X     |  A     | -2     | Василий по заданию №1
|===

== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|09.04.2020|X     |  A     | -2     | Василий по заданию №1
|09.04.2020|X     |  B     | 2     | Василий по заданию №1
|===

== А если мы ошиблись с учётом?

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|9.04.2020|X     |  A     | -2     | Василий по заданию №1
|9.04.2020|X     |  B     | 2     | Василий по заданию №1
|9.04.2020|X     |  A     | 2     | Сторно задания №1
|9.04.2020|X     |  B     | -2     | Сторно задания №1

|===


== На какие вопросы уже можно ответить?

[%step]
* Сколько у нас всего на складе товара Y?
* Что лежит в ячейке B?
* Сколько товаров переместил Василий 9 апреля?
* Какие корректировки вносились в систему?

== Расследуем инцидент

* 9 апреля Василий должен был положить товар из A в В.
* Давайте посмотрим, что лежит в A?
* Давайте спросим Василия?

== На какие вопросы можно будет легко ответить?

[%step]
* Нагрузка на полку лимитирована 100 кг
* -- Добавляем поле "вес" в Ledger!
* Нужно посчитать зарплату работников склада
* -- Даже добавлять ничего не надо.



== Архитектура решения: лог не работает в одиночку

[graphviz,erp-architecture,png]
----
digraph G {
  graph[dpi="180"];
  rankdir="LR";
  A[label="Documents",shape="cylinder"];
  B[label="Posting",shape="rectable",style="rounded"];
  Ledger [shape="none",label="",
      image="src/main/asciidoc/images/oak-log-cropped.png"];
  Caption[label="Log (ledger)",shape="plaintext"];
  
  {rank = same; Ledger; Caption;}
  C[label="Aggregating",shape="rectable",style="rounded"];
  D[label="Balance Sheets\nReports\netc",shape="cylinder"];
  A->B;
  B->Ledger;
  Ledger->C;
  C->D;
}
----

== Предварительный итог

Наличие лога позволяет

[%step]
* Добавлять новую функциональность
* Искать корелляции событий, выявлять и расследовать мошенническое поведение
* Исправлять алгоритмические ошибки и пересчитывать данные
* Наша жизнь -- это append-only log

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. *Что такое Kafka и что она умеет*
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. Что такое Kafka и что она умеет
.. *Общая информация*
.. Как устроен кластер
.. Как устроена запись
.. Как устроено чтение
.. Retention и компактификация
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Kafka это

[cols="1a,2a,3a,1a"]
|===
<.^|
|image::kafka-logo.svg[]
<.^|
* распределённый
* масштабируемый
* отказоустойчивый лог
* https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines[миллионы записей в секунду]
<.^|
|===


== В Кафке можно

[cols="1a,2a"]
|===
| image::okay.png[]
|* Записать нечто в именованный лог (topic)
* Прочитать записи из топика в FIFO порядке (в пределах партиции)
* Зафиксировать место, до которого дочитал

|===

== В Кафке нельзя

[cols="1a,2a"]
|===
| image::noway.png[]
|* Стереть запись
* Изменить запись
* Найти в логе запись иначе, как по её порядковому номеру
|===


== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. Что такое Kafka и что она умеет
.. [line-through]#Общая информация#
.. *Как устроен кластер*
.. Как устроена запись
.. Как устроено чтение
.. Retention и компактификация
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Кластер Kafka: брокеры и Zookeeper

[graphviz,cluster-anatomy,png]
----
digraph D {
  graph [ dpi = 180 ]; 
  b1[shape="rectangle",label="",
      image="src/main/asciidoc/images/kafka-logo-small.png"];

  b2[shape="rectangle",label="",
      image="src/main/asciidoc/images/kafka-logo-small.png"];

  b3[shape="rectangle",label="",
      image="src/main/asciidoc/images/kafka-logo-small.png"];

  zk1[shape="rectangle",label="",
      image="src/main/asciidoc/images/zookeeper-logo-small.png"];

  zk2[shape="rectangle",label="",
      image="src/main/asciidoc/images/zookeeper-logo-small.png"];

  zk3[shape="rectangle",label="",
      image="src/main/asciidoc/images/zookeeper-logo-small.png"];
      
  b1->zk1[style="invis"];
  b2->zk2[style="invis"];
  b3->zk3[style="invis"];
}
----

== Топики, партиции и сообщения

[graphviz,topics-partitions,png]
----
digraph D {
  graph [ dpi = 180 ]; 

   rankdir = LR;
    subgraph cluster_t1 {
      label = "topic A";
      style = "rounded";
      T1[shape="none"; style="invis"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }
     
    subgraph cluster_t2 {
      label = "topic B";
      style = "rounded";
      T2[shape="none"; style="invis"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]

    }   


    subgraph cluster_t3 {
      label = "topic C";
      style = "rounded";
      T3[shape="none"; style="invis"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>3</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }   
    
    T1:p0->T2:p0->T3:p0[style="invis"]
    
} 
----


== Топики, партиции и сообщения

[graphviz,topics-partitions1,png]
----
digraph D {
  graph [ dpi = 180 ]; 

   rankdir = LR;
    subgraph cluster_t1 {
      label = "topic A";
      style = "rounded";
      T1[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }
     
    subgraph cluster_t2 {
      label = "topic B";
      style = "rounded";
      T2[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]

    }   


    subgraph cluster_t3 {
      label = "topic C";
      style = "rounded";
      T3[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>3</td><vr/><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td style="invis"><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }   
    
    T1:p0->T2:p0->T3:p0[style="invis"]
    
} 
----

== Топики, партиции и сообщения

[graphviz,topics-partitions2,png]
----
digraph D {
  graph [ dpi = 180 ]; 

   rankdir = LR;
    subgraph cluster_t1 {
      label = "topic A";
      style = "rounded";
      T1[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }
     
    subgraph cluster_t2 {
      label = "topic B";
      style = "rounded";
      T2[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]

    }   


    subgraph cluster_t3 {
      label = "topic C";
      style = "rounded";
      T3[shape="none"; label=<<table cellspacing="5" cellborder="0"  border="1">
        <tr><td>0</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>1</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>2</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        <hr/>
        <tr><td>3</td><vr/><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td><td><IMG SCALE="BOTH" SRC="src/main/asciidoc/images/message-small.png"/></td></tr>
        </table>>]
    }   
    
    T1:p0->T2:p0->T3:p0[style="invis"]
    
} 
----

[.replication]
== Репликация партиций

[graphviz,broker-topics0,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    
    b3p2[label="partition 2"];
    b3p3[label="partition 3",style=filled; fillcolor="#4db34d"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="", style="invis",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="", style="invis",
                 image="src/main/asciidoc/images/smile.png"];
    R3[shape="none",label="", style="invis",
                 image="src/main/asciidoc/images/smile.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3;
  
  R1->b1p1[dir="none", style="invis"];
  R2->b2p2[dir="none", style="invis"];
  R3->b3p3[dir="none", style="invis"];

}

----


[.replication]
== Репликация партиций

[graphviz,broker-topics1,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    
    b3p2[label="partition 2"];
    b3p3[label="partition 3",style=filled; fillcolor="#4db34d"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3;
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none"];

}

----


[.replication]
== Репликация партиций

[graphviz,broker-topics2,png, role="dizzy"]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3";
    style=filled;
    
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2[style=invis];
  b3p3->b1p3[style=invis];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none",style="dashed"];
  
}

----

[.replication]
== Репликация партиций

[graphviz,broker-topics3,png, role="dizzy"]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3",style=filled; fillcolor="#4db34d"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3";
    style=filled;
    
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2[weight=10,style=invis];
  b3p3->b1p3[style=invis];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b1p3[dir="none",weight=0];
}

----

[.replication]
== Репликация партиций

[graphviz,broker-topics4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3",style=filled; fillcolor="#4db34d"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  
  b1p1->b2p2[weight=10,style=invis];
  b2p2->b3p2[weight=10,style=invis];
  
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3[dir=back];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b1p3[dir="none",weight=0];
}

----

[.replication]
== Репликация партиций

[graphviz,broker-topics5,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b1p1[label="partition 1",style=filled; fillcolor="#4db34d"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="#4db34d"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    
    b3p2[label="partition 2"];
    b3p3[label="partition 3",style=filled; fillcolor="#4db34d"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smile.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3;
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none"];
}
----

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. Что такое Kafka и что она умеет
.. [line-through]#Общая информация#
.. [line-through]#Как устроен кластер#
.. *Как устроена запись*
.. Как устроено чтение
.. Retention и компактификация
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Анатомия сообщения

[graphviz,message-anatomy,png]
----
digraph G {
  graph [ dpi = 200 ];
  msg[
    shape="none";
    label=<<table cellspacing="5" cellborder="0" style="rounded" border="1">
                    <tr><td><IMG SCALE="TRUE" SRC="src/main/asciidoc/images/message.png"/></td></tr>
                    <hr/>
                    <tr><td>Номер партиции</td></tr>
                    <hr/>
                    <tr><td>Ключ</td></tr>
                    <hr/>
                    <tr><td>Значение</td></tr>
                    <hr/>
                    <tr><td>Заголовки</td></tr>
            </table>>;
            
  ]
}
----


== Анатомия сообщения

[graphviz,message-anatomy2,png]
----
digraph G {
  graph [ dpi = 200 ];
  msg[
    shape="none";
    label=<<table cellspacing="5" cellborder="0" style="rounded" border="1">
                    <tr><td><IMG SCALE="TRUE" SRC="src/main/asciidoc/images/message.png"/></td></tr>
                    <hr/>
                    <tr><td bgcolor="gray">Номер партиции</td></tr>
                    <hr/>
                    <tr><td bgcolor="gray">Ключ</td></tr>
                    <hr/>
                    <tr><td>Значение</td></tr>
                    <hr/>
                    <tr><td>Заголовки</td></tr>
            </table>>;
            
  ]
}
----

[source,java]
----
// hash the keyBytes to choose a partition
return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
----


== Пропускная способность vs время ожидания

`batch.size` and `linger.ms`

[cols=2]
|===
a|image::not_brand/low-throughput.jpg[]
a|image::not_brand/high-throughput.jpg[]
|===

== Запись в Кафку

`acks` = 0

&nbsp;

[graphviz,prod1,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    b3p1[label="partition 1"];
    label="broker 3";
  }
 
  b1p1->b2p1->b3p1[style="invis"]
  
  a[shape="none",label="",
                 image="src/main/asciidoc/images/zany.png"];
  a->b1p1[lhead="cluster_broker1",dir=back];
  a->b1p1[lhead="cluster_broker1"];
  
 

}

----


== Запись в Кафку

`acks` = 1

&nbsp;


[graphviz,prod2,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1",style="filled",fillcolor="#4db34d"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1"];
    label="broker 2"
  }
 
  subgraph cluster_broker3{
    b3p1[label="partition 1"];
    label="broker 3";
  }
 
  b1p1->b2p1->b3p1[style="invis"]
  

  a[shape="none",label="",
                 image="src/main/asciidoc/images/suspicious.png"];

  a->b1p1[dir=back];
  a->b1p1[];


}

----


== Запись в Кафку

`acks` = -1

`min.insync.replicas`


[graphviz,prod3,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1",style="filled",fillcolor="#4db34d"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1",style="filled",fillcolor="#4db34d"];
    label="broker 2"
  }
 
  subgraph cluster_broker3{
    b3p1[label="partition 1",style="filled",fillcolor="#4db34d"];
    label="broker 3";
  }
 
  b1p1->b2p1[weight=10];
  b1p1->b2p1[weight=10;dir=back];
  b2p1->b3p1[weight=10;style=invis];
  
  
  
  b1p1->b3p1->b1p1;
  
  a[shape="none",label="",
                 image="src/main/asciidoc/images/fear.png"];

  a->b1p1[dir=back];
  a->b1p1[];
}
----

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. Что такое Kafka и что она умеет
.. [line-through]#Общая информация#
.. [line-through]#Как устроен кластер#
.. [line-through]#Как устроена запись#
.. *Как устроено чтение*
.. Retention и компактификация
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===


== Чтение из Кафки

[graphviz,ConsumerG0,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  subgraph cluster_s2{
    o1[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"]
    label="Consumer Group"
    style="rounded"
  }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o1
  }
}
----

== Чтение из Кафки

[graphviz,ConsumerG,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
      subgraph cluster_s2{
          
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
          
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
        
        label="Consumer Group";
        style="rounded"
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o2    
  }
}
----

== Чтение из Кафки
[graphviz,ConsumerG2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
  
  
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        label="Consumer Group"
        style="rounded"
        
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
}
----

== Чтение из Кафки
[graphviz,ConsumerG3,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
  
  
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o4[shape="none",label="",
                 image="src/main/asciidoc/images/rollingeyes.png"]
        
        o1->o4[style="invis"];
        label="Consumer Group"
        style="rounded"
        
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
}
----

== Offset Commit

[graphviz,offcommit1,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
   
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit2,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit3,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back]
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit4,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----


== Offset Commit

[graphviz,offcommit5,png]
----
digraph G {
   graph [ dpi = 200 ];
    rankdir="LR"
    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
    

    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back] 
}
----

== Offset Commit

[graphviz,offcommit6,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"

    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
   
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back]  
}
----

== Offset Commit

[graphviz,offcommit7,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"

    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
   
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4d4cb4">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="#4db34d">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back]  
}
----

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
. [line-through]#Что такое лог и почему это важно#
. Что такое Kafka и что она умеет
.. [line-through]#Общая информация#
.. [line-through]#Как устроен кластер#
.. [line-through]#Как устроена запись#
.. [line-through]#Как устроено чтение#
.. *Retention и компактификация*
. Что такое потоковая архитектура и на что способны потоковые обработчики
. Kafka и JavaScript
. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===


== Как работает retention

[graphviz,retention0,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s1
  {rank =same; nm; s1}

}
----

== Как работает retention

[graphviz,retention1,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  s2[label="segment 2"]
  s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s2
  {rank =same; nm; s2}

}
----

== Как работает retention

[graphviz,retention2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  s2[label="segment 2"]
  s3[label="segment 3"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention3,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1",style="filled" fillcolor="#634545"; fontcolor="#ffffff"]
  s2[label="segment 2"]
  s3[label="segment 3"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/surprised.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 2"]
  s2[label="segment 3"]
  s3[label="segment 4"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention5,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 3"]
  s2[label="segment 4"]
  s3[label="segment 5"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----


[%notitle]
== Kafka как зацикленная магнитофонная плёнка

image::tapeloop.jpg[{image-60-width}]

== Компактификация топиков

.Источник: Kafka Documentation
image::log_compaction.png[{image-60-width}]

== Наш план
[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. *Что такое потоковая архитектура и на что способны потоковые обработчики*
4. Kafka и JavaScript
5. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===


== Потоковая обработка данных: архитектура

[graphviz,streaming-arch1,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== Существующие фреймворки потоковой обработки

[cols=".^1a,.^1a,.^1a,.^1a,.^1a"]
|===
|image::spark-logo.svg[]
|image::samza-logo.svg[]
|image::storm-logo.svg[]
|image::flink-logo.svg[]
|image::kafka-logo.svg[]
|===


== Когда меня спрашивают, какой стриминговый фреймворк использовать

image::weuseflink1.jpg[{image-90-width}]


== Когда меня спрашивают, какой стриминговый фреймворк использовать

image::weuseflink2.jpg[{image-90-width}]

== Stateless Transformation
[graphviz, "yelling-topology1.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
Source[style=filled; fillcolor="#634545"; fontcolor="#ffffff"];
Source -> MapVal -> Sink

}
-----

[source,java]
----
KStream<String, String> stream =  streamsBuilder.stream(
     SRC_TOPIC, Consumed.with(Serdes.String(), Serdes.String());
----


== Stateless Transformation
[graphviz, "yelling-topology2.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
MapVal[style=filled; fillcolor="#634545"; fontcolor="#ffffff"];

Source -> MapVal -> Sink

}
-----

[source,java]
----
KStream<String, String> upperCasedStream =
    stream.mapValues(String::toUpperCase);
----


== Stateless Transformation
[graphviz, "yelling-topology3.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
Sink[style=filled; fillcolor="#634545"; fontcolor="#ffffff"];

Source -> MapVal -> Sink

}
-----

[source,java,highlight='7-8']
----
upperCasedStream.to(SINK_TOPIC,
     Produced.with(Serdes.String(), Serdes.String());
----

== Три строчки кода, ну и что тут такого?

* Больше сообщений в секунду? -- больше машин с одинаковым  `application.id`!

[graphviz,w1,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
  
    subgraph cluster_s2{
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"];
        label="APP_ID_1";
        style="rounded";
   }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o1  
    label="source-topic"
    
  }
  
  sink[label="sink-topic"]
  o1->sink
}
----

== Добавляем ноды

[graphviz,w2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
      subgraph cluster_s2{
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
        label="APP_ID_1";
        style="rounded";
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o2 
    label="source-topic"
  }
  
  sink[label="sink-topic"]
  o1->sink
  o2->sink
}
----

== Ограничены только числом партиций

[graphviz,w4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o4[shape="none",label="",
                 image="src/main/asciidoc/images/rollingeyes.png"]

        label="APP_ID_1";
        style="rounded";
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
  sink[label="sink-topic"]
  o1->sink
  o2->sink
  o3->sink
}
----



== Магия Stateful Transformation
[graphviz, "counting-topology-changelog1.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store [shape="cylinder"; label="RocksDB"; fixedsize="true"; width="1.5"]
Source -> MapVal -> Sum -> Sink
Sum -> Store [dir=both; label=" \n "]
{rank = same; Store; Sum;}
Store -> Changelog[style="invis"]
Changelog[shape="box"; style="invis"; width="1.5"; fillcolor="#634545"; fontcolor="#ffffff";]
}
-----

== Изменения реплицируются в топик!
[graphviz, "counting-topology-changelog2.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store [shape="cylinder"; label="RocksDB"; fixedsize="true"; width="1.5"]
Source -> MapVal -> Sum -> Sink
Sum -> Store [dir=both; label=" \n "]
{rank = same; Store; Sum;}
Store -> Changelog
Changelog[shape="box"; style="filled"; width="1.5"; fillcolor="#634545"; fontcolor="#ffffff";]
}
-----

== Партиционирование и local state
[graphviz, "local-partitioning-oneworker.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S1->S2 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }

        d->ls1;
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
          
        
        ls1[shape="cylinder" label = <<table border="0" cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">15</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">10</font></td>
        <vr/><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">20</font></td></tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
    }

  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-1.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }

        d->ls1;
        
        ls1->p3v1;
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">15</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">10</font></td>
        <vr/><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">20</font></td></tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p2v1;
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>10</td></tr></table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>20</td></tr></table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>15</td></tr></table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-2.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }

        d->ls1;
        
        ls1->p3v1;
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">19</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">12</font></td>
        <vr/><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">22</font></td></tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p2v1;
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>10</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>12</td></tr>
        </table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>20</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>22</td></tr>
        </table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>15</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>19</td></tr>
        </table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-25.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";

          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">19</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">12</font></td>
        </tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p3v1;
    }


    subgraph cluster_p2 {
      label = "Worker 2";
         subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }
      
        ls2[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td><img src="src/main/asciidoc/images/question-mark.png"/></td></tr></table>>]
        d->ls2;
        ls2->p2v1[style="invis"];
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>10</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>12</td></tr>
        </table>>];
        p2v1[shape="none"; style="invis"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>20</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>22</td></tr>
        </table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>15</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>19</td></tr>
        </table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-3.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";

          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">19</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">12</font></td>
        </tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p3v1;
    }


    subgraph cluster_p2 {
      label = "Worker 2";
         subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }
      
        ls2[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">22</font></td></tr></table>>]
        d->ls2;
        ls2->p2v1[dir="back"];
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>10</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>12</td></tr>
        </table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>20</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>22</td></tr>
        </table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>15</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>19</td></tr>
        </table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-4.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";

          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">21</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">13</font></td>
        </tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p3v1;
    }


    subgraph cluster_p2 {
      label = "Worker 2";
         subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }
      
        ls2[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">23</font></td></tr></table>>]
        d->ls2;
        ls2->p2v1;
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>10</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>12</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>13</td></tr>
        </table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
         <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>20</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>22</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>23</td></tr>
        </table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>15</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>19</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>21</td></tr>
        </table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-5.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";

          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">21</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">13</font></td>
        </tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p3v1;
    }


    subgraph cluster_p2 {
      label = "Worker 2";
         subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }
      
        ls2[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">23</font></td></tr></table>>]
        d->ls2;
        ls2->p2v1;
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>13</td></tr>
        </table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>23</td></tr>        
        </table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>21</td></tr>
        </table>>];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-6.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[shape="none", label="",
                 image="src/main/asciidoc/images/pear.png"];
          }

        d->ls1;
        
        ls1->p3v1;
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [shape="none", label="",
                 image="src/main/asciidoc/images/red-apple.png"];
              c[shape="none", label="",
                 image="src/main/asciidoc/images/kiwi.png"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [shape="none", label="",
                 image="src/main/asciidoc/images/banana.png"];
              
          }
        
        ls1[shape="cylinder" label = <<table border="0"  cellspacing="5">
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td><font point-size="24">21</font></td>
        <vr/><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td><font point-size="24">13</font></td>
        <vr/><td><img src="src/main/asciidoc/images/pear.png"/></td><td><font point-size="24">23</font></td></tr></table>>]
        a->ls1;
        b->ls1;
        c->ls1;
        
        ls1->p1v1;
        ls1->p2v1;
    }

        p1v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 2</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/red-apple.png"/></td><td>13</td></tr></table>>];
        p2v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 3</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/pear.png"/></td><td>23</td></tr></table>>];
        p3v1[shape="none"; label= <<table cellborder="0">
        <tr><td colspan="2">Partition 1</td></tr>
        <hr/>
        <tr><td><img src="src/main/asciidoc/images/banana.png"/></td><td>21</td></tr></table>>];
  }
} 
-----


== Что ещё умеют стримы?

Соединять источники!

[graphviz, "join-storages.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store1 [shape="cylinder"; label="Local Store 1"; fixedsize="true"; width="1.7"]
Store2 [shape="cylinder"; label="Local Store 2"; fixedsize="true"; width="1.7"]
Source1 -> Join
Source2 -> Join

Join -> Sink
Join -> Store1 [dir=both; label=" \n "]
Join -> Store2 [dir=both; label=" \n "]
Store1 -> Store2 [style=invis]
{rank = same; Store1; Join }

}
-----

== Агрегировать данные во временных окнах

.Источник: Kafka Streams in Action
image::tumbling-window.png[{image-70-width}]

== «Склеивать» данные, относящиеся к рабочей сессии

image::streams-session-windows-02.png[{image-50-width}]

== KSQL 


[source,sql]
----
CREATE STREAM pageviews_enriched AS
  SELECT pv.viewtime,
         pv.userid AS userid,
         pv.pageid,
         pv.timestring,
         u.gender,
         u.regionid,
         u.interests,
         u.contactinfo
  FROM pageviews_transformed pv
  LEFT JOIN users_5part u ON pv.userid = u.userid
  EMIT CHANGES;
----

== KSQL


[source,sql]
----
CREATE TABLE pageviews_per_region_per_30secs AS
  SELECT regionid,
         count(*)
  FROM pageviews_enriched
  WINDOW TUMBLING (SIZE 30 SECONDS)
  WHERE UCASE(gender)='FEMALE' AND LCASE(regionid)='region_6'
  GROUP BY regionid
  EMIT CHANGES;
----

== Кейсы для потоковых систем

* Мониторинг! Логи!
* Отслеживание действий пользователей
* Выявление аномалий (в т. ч. попыток мошенничества)

[%notitle]
== Всюду, где ценность/влияние данных уменьшается с их «возрастом»
image::streams-ok.svg[{image-90-width}]


[%notitle]
== Kafka -- это зацикленная плёнка
image::tapeloop.jpg[{image-60-width}]

[%notitle]
== Где использовать Kafka не очень удобно
image::streams-noway.svg[{image-90-width}]

== О чём следует помнить

* При изменении схемы данных миграция не похожа на RDBMS.
* Once-only delivery:
** В обычном режиме, сбой в KStreams приводит к повторному чтению данных.
** В режиме once-only delivery -- чтение и запись между топиками Kafka.

== Если нужно хранить данные всё время

* Лямбда-архитектура

[cols="30a,70a"]
|===
.^|image::nikita_salnikov.jpg[]
.^|
*Никита Сальников-Тарновский* //https://2019.jokerconf.com/2019/talks/2qw2ljhlfoeiipjf0gfzzb/[Потоковое приложение — это не только код, но и 3-4 года поддержки в проде]
|===

== Наш план

[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. [line-through]#Что такое потоковая архитектура и на что способны потоковые обработчики#
4. *Kafka и JavaScript*
5. Как попробовать Кафку сегодня
.<|image::kafka.jpg[]
|===

== Kafka и Javascript

[graphviz,streaming-arch2,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded";];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== Kafka и Javascript

[graphviz,streaming-arch3,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded,filled"; fillcolor="#634545"; fontcolor="#ffffff";];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== kafka-node

image::kafka-node.png[]

* Лидер по звёздам и количеству использований
* Чистая JavaScript-реализация
* Умеет не всё.

== node-rdkafka

image::node-rdkafka.png[]

* Github-метрики проигрывают kafka-node
* JavaScript/C++
* Обёртка вокруг librdkafka -- очень зрелого проекта
* Умеет работать с Confluent Cloud


== Преобразующий/выходной каскад на node.js?

[graphviz,streaming-arch4,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded,filled" fillcolor="#634545"; fontcolor="#ffffff";];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----



== Преобразующий/выходной каскад на node.js?

[cols=">40a,60a"]
|===
|image::nodefluent.png[]
|
https://github.com/nodefluent[Nodefluent]

* node-sinek -- ещё один клиент
* kafka-streams -- реимплементация KStreams для node.js
* kafka-connect -- реимплементация kafka-connect
|===

== KSQL + Serverless

[graphviz,streaming-arch5,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier\n(KSQL)",shape="rectangle",style="rounded"];
 
  E[label="Consumer\n(serverless)",shape="rectangle",style="rounded,filled"fillcolor="#634545"; fontcolor="#ffffff";];
  A->Ledger1->C->E;
}
----

https://www.confluent.io/kafka-summit-lon19/event-sourcing-stream-processing-serverless[Benjamin Stopford: Event Sourcing, Stream Processing and Serverless]

== Наш план

[cols="20a,60a,20a"]
|===
.<|image::kafka.jpg[]
.<|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. [line-through]#Что такое потоковая архитектура и на что способны потоковые обработчики#
4. [line-through]#Kafka и JavaScript#
5. *Как попробовать Кафку сегодня*
.<|image::kafka.jpg[]
|===

== Вы решили попробовать Кафку. С чего начать?

https://kafka.apache.org/downloads

`kafkacat` -- лучший CLI инструмент

image::conduktor.png[]

Conduktor -- лучший GUI инструмент

[%notitle]
== Conduktor

image::conduktor-screen.png[]

== Эксплуатировать Кафку в production тяжело

[cols="30a,70a"]
|===
.^|image::koshelev.png[]
.^|
*Григорий Кошелев*

* https://2019.jpoint.ru/talks/1xa5ea6p9djq1phnauiygm/[Когда всё пошло по Кафке]
* https://2019.devoops-piter.ru/2019/spb/talks/3cq28gbf1fzn40dpbq6bpu/[Как готовить Кафку, чтобы не пригорало]
|===



== Kafka: The Definitive Guide

[.custom-style]
[cols="30a,70a"]
|===
|image::kafka-the-definitive-guide.jpg[]
|
* Gwen Shapira, Todd Palino, Rajini Sivaram, Krit Petty
* November 2021
|===


== Сообщества, конференции
- Kafka Summit Conference: https://kafka-summit.org/

image::kafka-summit.png[{image-50-width}]

== Телеграм

Грефневая Кафка

* https://t.me/AwesomeKafka_ru
* https://t.me/proKafka

== Митап в Москве 

Moscow Apache Kafka® Meetup by Confluent -- раз в квартал


== На этом всё!

[cols=">.^40a,<.^60a"]
|===
|image::kafka-logo.svg[{image-30-width}]
|image::conduktor.png[]
|===

icon:twitter[size=lg] https://twitter.com/inponomarev[@inponomarev]

ponomarev@corchestra.ru

*Спасибо!*