= Apache Kafka: что это и как она изменит архитектуру вашего приложения
Иван Пономарёв, КУРС/МФТИ
:revealjs_theme: black
:revealjs_customtheme: white_course.css
:revealjs_slideNumber:
:revealjs_history:
:revealjs_progress:
:encoding: UTF-8
:lang: ru
include::_doc_general_attributes.adoc[]
:doctype: article
:toclevels: 3
:imagesdir: images
:source-highlighter: highlightjs
:highlightjsdir: highlight
:icons: font
:iconfont-remote!:
:iconfont-name: font-awesome-4.7.0/css/font-awesome
:revealjs_mouseWheel: true
:revealjs_center: false
:revealjs_transition: none
:revealjs_width: 1600
:revealjs_height: 900


//== Часть 1. Введение
:!figure-caption:

ponomarev@corchestra.ru

icon:twitter[size=lg] @inponomarev

[%notitle]
== Кто я такой

[cols="30a,70a"]
|===
.^|image::me.jpg[]
.^|
* Tech Lead at KURS
* ERP systems & Java background
* Speaker at JPoint, Devoops, Heisenbug, JUG.MSK, etc.
* Twitter @inponomarev
|===

== Наш план
[cols="20a,60a,20a"]
|===
.^|image::kafka.jpg[]
.^|
1. *Что такое лог и почему это важно*
2. Что такое Kafka и что она умеет
3. Что такое потоковая архитектура и на что способны потоковые обработчики
4. Kafka и JavaScript
5. Как попробовать Кафку сегодня
.^|image::kafka.jpg[]
|===

== Что такое лог?

[%step]
* Добавляем данные в конец
* Записанное не можем изменить
* Читаем последовательно

[%notitle]
== Вступление

-- Что наша жизнь? 
[.fragment]
-- Лог!



== Автоматизировать склад. Как?

[.fragment]
[cols="1,1,1",options=header]
|===
|товар | ячейка | кол-во 
|X     |  A     | 8     
|X     |  B     | 2      
|Y     |  B     | 1      
|===

// База данных -- это склад?!

== Всё хорошо, пока...

// Надо взять товар с полки, но там пусто!

image::emptyshelf.jpg[]

== Что это может быть?

[cols=2]
|===
a|
[%step]
* Украли
* Потеряли: лежит где-то рядом
* Разбили и выкинули
a|
|===

== Что это может быть?

[cols=2]
|===
a|
* Украли
* Потеряли: лежит где-то рядом
* Разбили и выкинули
* *ЭТО ВАША ТУПАЯ ПРОГРАММА НЕ РАБОТАЕТ*
a|
image::upset-cropped.jpg[]

|===

== Что будем делать?

// * «Текущий снимок»? Делать нечего.
// * «База данных есть склад» -- просто, но не работает

image::messy.jpg[]


== Как на самом деле надо проектировать?

[cols="1a,3a"]
|===
|image::noway.png[]
<.^|* «База данных -- это склад»
|===

== Как на самом деле надо проектировать?

[cols="1a,3a"]
|===
|image::noway.png[]
<.^|* «База данных -- это склад»
|image::okay.png[]
<.^|

* База данных отражает процессы. 

* Текущее состояние -- результат выполнения процессов
|===


== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|===

== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|09.04.2020|X     |  A     | -2     | Василий по заданию №1
|===

== Warehouse Ledger

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|02.04.2020|X     |  A     | 10     | начальный остаток
|02.04.2020|X     |  B     | 2      | начальный остаток
|02.04.2020|Y     |  B     | 1      | начальный остаток
|09.04.2020|X     |  A     | -2     | Василий по заданию №1
|09.04.2020|X     |  B     | 2     | Василий по заданию №1
|===

== А если мы ошиблись с учётом?

[cols="1,1,1,1,1",options=header]
|===

|дата |товар | ячейка | кол-во | описание
|9.04.2020|X     |  A     | -2     | Василий по заданию №1
|9.04.2020|X     |  B     | 2     | Василий по заданию №1
|9.04.2020|X     |  A     | 2     | Сторно задания №1
|9.04.2020|X     |  B     | -2     | Сторно задания №1

|===


== На какие вопросы уже можно ответить?

[%step]
* Сколько у нас всего на складе товара Y?
* Что лежит в ячейке B?
* Сколько товаров переместил Василий 9 апреля?
* Какие корректировки вносились в систему?

== Расследуем инцидент

* 9 апреля Василий должен был положить товар из A в В.
* Давайте посмотрим, что лежит в A?
* Давайте спросим Василия?

== На какие вопросы можно будет легко ответить?

[%step]
* Нагрузка на полку лимитирована 100 кг
* -- Добавляем поле "вес" в Ledger!
* Нужно посчитать зарплату работников склада
* -- Даже добавлять ничего не надо.



== Архитектура решения: Ledger не работает в одиночку

[graphviz,erp-architecture,png]
----
digraph G {
  graph[dpi="180"];
  rankdir="LR";
  A[label="Documents",shape="cylinder"];
  B[label="Posting",shape="rectable",style="rounded"];
  Ledger [shape="record",label="{ | | | | }"];
  Caption[label="Ledger",shape="plaintext"];
  
  {rank = same; Ledger; Caption;}
  C[label="Aggregating",shape="rectable",style="rounded"];
  D[label="Balance Sheets\nReports\netc",shape="cylinder"];
  A->B;
  B->Ledger;
  Ledger->C;
  C->D;
}
----

== Подведём итоги

Наличие лога позволяет

[%step]
* Добавлять новую функциональность
* Искать корелляции событий, выявлять и расследовать мошенническое поведение
* Исправлять алгоритмические ошибки и пересчитывать данные
* Наша жизнь -- это append-only log

== Наш план
[cols="20a,60a,20a"]
|===
.^|image::kafka.jpg[]
.^|
1. [line-through]#Что такое лог и почему это важно#
2. *Что такое Kafka и что она умеет*
3. Что такое потоковая архитектура и на что способны потоковые обработчики
4. Kafka и JavaScript
5. Как попробовать Кафку сегодня
.^|image::kafka.jpg[]
|===

== Kafka это

[cols="1a,1a"]
|===
|image::kafka-logo.svg[]
<.^|
* распределённый
* масштабируемый
* отказоустойчивый лог
* https://engineering.linkedin.com/kafka/benchmarking-apache-kafka-2-million-writes-second-three-cheap-machines[миллионы записей в секунду]
|===


== В Кафке можно

[cols="1a,2a"]
|===
| image::okay.png[]
|* Записать нечто в именованный лог (topic)
* Прочитать записи из топика в FIFO порядке (в пределах партиции)
* Зафиксировать место, до которого дочитал

|===

== В Кафке нельзя

[cols="1a,2a"]
|===
| image::noway.png[]
|* Стереть запись
* Изменить запись
* Найти в логе запись иначе, как по её порядковому номеру
|===

== Лог или очередь сообщений?

* Данные сразу записываются на диск и реплицируются
* Данные не теряются после вычитывания
* Могут быть прочитаны несколькими потребителями
* Не брокер уведомляет консьюмеров, а консьюмеры забирают их

// == TODO: база данных наизнанку

== Кластер Kafka: брокеры и Zookeeper

[cols=3]
|===
a|
Broker

image::kafka-logo.svg[{image-40-width}] 

a|
Broker

image::kafka-logo.svg[{image-40-width}] 
a|
Broker

image::kafka-logo.svg[{image-40-width}] 
a|
Zookeeper

image::zookeeper-logo.png[{image-20-width}]
a|
Zookeeper

image::zookeeper-logo.png[{image-20-width}] 

a|
Zookeeper

image::zookeeper-logo.png[{image-20-width}]
|===



== Топики и партиции

[graphviz,topics-partitions,png]
----
digraph D {
  graph [ dpi = 180 ]; 

   rankdir = LR;
    subgraph cluster_t1 {
      label = "topic A";
      style = "rounded";
      T1[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3|partition 4"; style="invis"]
    }
     
    subgraph cluster_t2 {
      label = "topic B";
      style = "rounded";
      T2[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3"; style="invis"]

    }   


    subgraph cluster_t3 {
      label = "topic C";
      style = "rounded";
      T3[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3|partition 4|partition 5"; style="invis"]
    }   
    
    T1:p0->T2:p0->T3:p0[style=invis]
} 
----

== Топики и партиции

[graphviz,topics-partitions2,png]
----
digraph D {
  graph [ dpi = 180 ]; 

   rankdir = LR;
    subgraph cluster_t1 {
      label = "topic A";
      style = "rounded";
      T1[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3|partition 4"]
    }
     
    subgraph cluster_t2 {
      label = "topic B";
      style = "rounded";
      T2[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3"]

    }   


    subgraph cluster_t3 {
      label = "topic C";
      style = "rounded";
      T3[shape="record"; label="<p0>partition 0|partition 1|partition 2|partition 3|partition 4|partition 5"]
    }   
    
    T1:p0->T2:p0->T3:p0[style=invis]
} 
----


== Репликация партиций

[graphviz,broker-topics,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b1p1[label="partition 1",style=filled; fillcolor="green"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="green"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    
    b3p2[label="partition 2"];
    b3p3[label="partition 3",style=filled; fillcolor="green"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3;
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none"];

}

----



== Репликация партиций

[graphviz,broker-topics2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b1p1[label="partition 1",style=filled; fillcolor="green"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="green"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3";
    style=filled;
    
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2[style=invis];
  b3p3->b1p3[style=invis];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none",style="dashed"];
  
}

----

== Репликация партиций

[graphviz,broker-topics3,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    b1p1[label="partition 1",style=filled; fillcolor="green"];
    b1p3[label="partition 3",style=filled; fillcolor="green"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="green"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3";
    style=filled;
    
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2[weight=10,style=invis];
  b3p3->b1p3[style=invis];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b1p3[dir="none",weight=0];
}

----


== Репликация партиций

[graphviz,broker-topics4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
    b1p1[label="partition 1",style=filled; fillcolor="green"];
    b1p3[label="partition 3",style=filled; fillcolor="green"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="green"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b3p2[label="partition 2"];
    b3p3[label="partition 3"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  
  b1p1->b2p2[weight=10,style=invis];
  b2p2->b3p2[weight=10,style=invis];
  
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3[dir=back];
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b1p3[dir="none",weight=0];
}

----

== Репликация партиций

[graphviz,broker-topics5,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    sm1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b1p1[label="partition 1",style=filled; fillcolor="green"];
    b1p3[label="partition 3"];
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    sm2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    b2p1[label="partition 1"];
    b2p2[label="partition 2",style=filled; fillcolor="green"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    sm3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    
    b3p2[label="partition 2"];
    b3p3[label="partition 3",style=filled; fillcolor="green"];
    label="broker 3"
  }
  
  subgraph cluster_clients{
    R1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
    R1->R2->R3[style=invis];
    style=invis;
  }
  
  b1p1->b2p2[weight=10,style=invis];
  b2p1->b3p2[weight=10,style=invis];
  b1p1->b2p1;
  b2p2->b3p2;
  b3p3->b1p3;
  
  R1->b1p1[dir="none"];
  R2->b2p2[dir="none"];
  R3->b3p3[dir="none"];
}
----

== Анатомия сообщения

[graphviz,message-anatomy,png]
----
digraph G {
  graph [ dpi = 200 ];
  msg[
    shape="none";
    label=<<table cellspacing="5" cellborder="0" style="rounded" border="1">
                    <tr><td><IMG SCALE="TRUE" SRC="src/main/asciidoc/images/message.png"/></td></tr>
                    <hr/>
                    <tr><td>Ключ</td></tr>
                    <hr/>
                    <tr><td>Значение</td></tr>
                    <hr/>
                    <tr><td>Номер партиции</td></tr>
            </table>>;
            
  ]
}
----

== В какую партицию полетит сообщение?
[source,java]
----
// hash the keyBytes to choose a partition
return Utils.toPositive(Utils.murmur2(keyBytes)) % numPartitions;
----

[source,java]
----
int part = Utils.toPositive(nextValue) % availablePartitions.size();
----

== Пропускная способность vs время ожидания

`batch.size` and `linger.ms`

[cols=2]
|===
a|image::low-throughput.jpg[]
a|image::high-throughput.jpg[]
|===

== Запись в Кафку

`acks` = 0

[graphviz,prod1,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1"];
    
    label="broker 2"
  }
  
  subgraph cluster_broker3{
    b3p1[label="partition 1"];
    label="broker 3";
  }
 
  b1p1->b2p1->b3p1[style="invis"]
  
  a[shape="none",label="",
                 image="src/main/asciidoc/images/zany.png"];
  a->b1p1[lhead="cluster_broker1",dir=back];
  a->b1p1[lhead="cluster_broker1"];
  
 

}

----


== Запись в Кафку

`acks` = 1

[graphviz,prod2,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1",style="filled",fillcolor="green"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1"];
    label="broker 2"
  }
 
  subgraph cluster_broker3{
    b3p1[label="partition 1"];
    label="broker 3";
  }
 
  b1p1->b2p1->b3p1[style="invis"]
  

  a[shape="none",label="",
                 image="src/main/asciidoc/images/suspicious.png"];

  a->b1p1[dir=back];
  a->b1p1[];


}

----


== Запись в Кафку

`acks` = -1

`min.insync.replicas`


[graphviz,prod3,png]
----
digraph G {
  node [shape="rectangle"];
  compound=true;
  graph [ dpi = 180 ];
  rankdir="LR";
  
   subgraph cluster_broker1{
    b1p1[label="partition 1",style="filled",fillcolor="green"];
    
    label="broker 1"
  }
  
  
  subgraph cluster_broker2{
    b2p1[label="partition 1",style="filled",fillcolor="green"];
    label="broker 2"
  }
 
  subgraph cluster_broker3{
    b3p1[label="partition 1",style="filled",fillcolor="green"];
    label="broker 3";
  }
 
  b1p1->b2p1[weight=10];
  b1p1->b2p1[weight=10;dir=back];
  b2p1->b3p1[weight=10;style=invis];
  
  
  
  b1p1->b3p1->b1p1;
  
  a[shape="none",label="",
                 image="src/main/asciidoc/images/fear.png"];

  a->b1p1[dir=back];
  a->b1p1[];
}
----

== Чтение из Кафки

[graphviz,ConsumerG0,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  subgraph cluster_s2{
    o1[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"]
    label="Consumer Group"
    style="rounded"
  }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o1
  }
}
----

== Чтение из Кафки

[graphviz,ConsumerG,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
      subgraph cluster_s2{
          
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
          
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"];
        
        label="Consumer Group";
        style="rounded"
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o2    
  }
}
----

== Чтение из Кафки
[graphviz,ConsumerG2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
  
  
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        label="Consumer Group"
        style="rounded"
        
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
}
----

== Чтение из Кафки
[graphviz,ConsumerG3,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 180 ];
  rankdir="LR";
  
  
  
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o4[shape="none",label="",
                 image="src/main/asciidoc/images/rollingeyes.png"]
        label="Consumer Group"
        style="rounded"
        
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
}
----

== Offset Commit

[graphviz,offcommit1,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
   
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit2,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit3,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
      subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back]
   Ledger->Consumer2[dir=back, style=invis]
}
----

== Offset Commit

[graphviz,offcommit4,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"
    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/dizzy.png"];
        Consumer2[shape="circle",style="rounded",label="C2",style="invis"]
        style="rounded";
        label="Group"
   }
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
   Ledger->Consumer[dir=back] 
   Ledger->Consumer2[dir=back, style=invis]
}
----


== Offset Commit

[graphviz,offcommit5,png]
----
digraph G {
   graph [ dpi = 200 ];
    rankdir="LR"
    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
    

    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back] 
}
----

== Offset Commit

[graphviz,offcommit6,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"

    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
   
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back]  
}
----

== Offset Commit

[graphviz,offcommit7,png]
----
digraph G {
    graph [ dpi = 200 ];
    rankdir="LR"

    subgraph cluster_s2{
        Consumer[shape="none",label="",
                 image="src/main/asciidoc/images/skull.png"];
        Consumer2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"];
        style="rounded";
        label="Group"
   }
   
    Ledger
    [
        shape = none
        label = <<table border="0" cellspacing="0">
                    <tr>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="blue">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="green">&nbsp;</td>
                    <td border="1" bgcolor="white">&nbsp;</td>
                    </tr>
                </table>>
    ]
    Ledger->Consumer[dir=back, style="invis"]
    Ledger->Consumer2[dir=back]  
}
----

// == At least once, at most once & exactly once в понимании Кафки
// TODO


== Как работает retention

[graphviz,retention0,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s1
  {rank =same; nm; s1}

}
----

== Как работает retention

[graphviz,retention1,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  s2[label="segment 2"]
  s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s2
  {rank =same; nm; s2}

}
----

== Как работает retention

[graphviz,retention2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1"]
  s2[label="segment 2"]
  s3[label="segment 3"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention3,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 1",style="filled"]
  s2[label="segment 2"]
  s3[label="segment 3"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/surprised.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 2"]
  s2[label="segment 3"]
  s3[label="segment 4"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----

== Как работает retention

[graphviz,retention5,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 190 ];
  rankdir="RL";
  
  s1[label="segment 3"]
  s2[label="segment 4"]
  s3[label="segment 5"]
  s3->s2->s1;
  
  nm[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
  nm->s3
  {rank =same; nm; s3}

}
----


[%notitle]
== Kafka как зацикленная магнитофонная плёнка

image::tapeloop.jpg[{image-70-width}]

== Компактификация топиков

.Источник: Kafka Documentation
image::log_compaction.png[{image-60-width}]

== Наш план
[cols="20a,60a,20a"]
|===
.^|image::kafka.jpg[]
.^|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. *Что такое потоковая архитектура и на что способны потоковые обработчики*
4. Kafka и JavaScript
5. Как попробовать Кафку сегодня
.^|image::kafka.jpg[]
|===


== Потоковая обработка данных: архитектура

[graphviz,streaming-arch1,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== Существующие фреймворки потоковой обработки

image::streaming-frameworks.png[]


== Когда меня спрашивают, какой стриминговый фреймворк использовать

image::weuseflink1.jpg[{image-90-width}]


== Когда меня спрашивают, какой стриминговый фреймворк использовать

image::weuseflink2.jpg[{image-90-width}]

== Stateless Transformation
[graphviz, "yelling-topology1.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
Source[style=filled; fillcolor="#ffffcc"];
Source -> MapVal -> Sink

}
-----

[source,java]
----
KStream<String, String> stream =  streamsBuilder.stream(
     SRC_TOPIC, Consumed.with(Serdes.String(), Serdes.String());
----


== Stateless Transformation
[graphviz, "yelling-topology2.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
MapVal[style=filled; fillcolor="#ffffcc"];

Source -> MapVal -> Sink

}
-----

[source,java]
----
KStream<String, String> upperCasedStream =
    stream.mapValues(String::toUpperCase);
----


== Stateless Transformation
[graphviz, "yelling-topology3.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=16; shape="circle"; fixedsize="true"; width="1.1"];
Sink[style=filled; fillcolor="#ffffcc"];

Source -> MapVal -> Sink

}
-----

[source,java,highlight='7-8']
----
upperCasedStream.to(SINK_TOPIC,
     Produced.with(Serdes.String(), Serdes.String());
----

== Три строчки кода, ну и что тут такого?

* Больше сообщений в секунду? -- больше машин с одинаковым  `application.id`!

[graphviz,w1,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
  
    subgraph cluster_s2{
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/worried.png"];
        label="APP_ID_1";
        style="rounded";
   }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o1  
    label="source-topic"
    
  }
  
  sink[label="sink-topic"]
  o1->sink
}
----

== Добавляем ноды

[graphviz,w2,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
      subgraph cluster_s2{
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/neutral.png"]
        label="APP_ID_1"
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o1
    "partition 3"->o2 
    label="source-topic"
  }
  
  sink[label="sink-topic"]
  o1->sink
  o2->sink
}
----

== Ограничены только числом партиций

[graphviz,w4,png]
----
digraph G {
  node [shape="rectangle"]
  graph [ dpi = 140 ];
  rankdir="LR";
      subgraph cluster_s2{
            
        o1[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]
        
        o2[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o3[shape="none",label="",
                 image="src/main/asciidoc/images/smiley.png"]

        o4[shape="none",label="",
                 image="src/main/asciidoc/images/rollingeyes.png"]

        label="APP_ID_1"
      }
  
  subgraph cluster_s1{
    "partition 1"->o1
    "partition 2"->o2
    "partition 3"->o3 
    label="source-topic"
  }
  
  sink[label="sink-topic"]
  o1->sink
  o2->sink
  o3->sink
}
----



== Магия Stateful Transformation
[graphviz, "counting-topology-changelog1.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store [shape="cylinder"; label="RocksDB"; fixedsize="true"; width="1.5"]
Source -> MapVal -> Sum -> Sink
Sum -> Store [dir=both; label=" \n "]
{rank = same; Store; Sum;}
Store -> Changelog[style="invis"]
Changelog[shape="box"; style="invis"; width="1.5"; fillcolor="#ffffcc"]
}
-----

== Изменения реплицируются в топик!
[graphviz, "counting-topology-changelog2.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store [shape="cylinder"; label="RocksDB"; fixedsize="true"; width="1.5"]
Source -> MapVal -> Sum -> Sink
Sum -> Store [dir=both; label=" \n "]
{rank = same; Store; Sum;}
Store -> Changelog
Changelog[shape="box"; style="filled"; width="1.5"; fillcolor="#ffffcc"]
}
-----

== Партиционирование и local state
[graphviz, "local-partitioning-oneworker.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        d->ls1;
        
        ls1->p3[dir="both"];
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "RocksDB"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
        
        
    }
    
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-1.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        d->ls1;
        
        ls1->p3[dir="both"];
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 15\nB: 10\nD: 20"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
        

    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1;
        p1v1[shape="record"; label="{B: 10}"];
        p2v1[shape="record"; label="{D: 20}"];
        p3v1[shape="record"; label="{A: 15}"];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-2.png"]
-----
digraph D {
  graph [ dpi = 150 ];
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        d->ls1;
        
        ls1->p3[dir="both"];
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 19\nB: 12\nD: 22"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
        

    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1;
        p1v1[shape="record"; label="{B: 12|B: 10}"];
        p2v1[shape="record"; label="{D: 22|D: 20}"];
        p3v1[shape="record"; label="{A: 19|A: 15}"];
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-25.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {
  
     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 19\nB: 12"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
    }
    subgraph cluster_p2 {
      label = "Worker 2";
      subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        ls2[shape="cylinder" label = "D: ???"]
        d->ls2;
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        ls2->p3[dir="both"];
    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1[style="invis"];
        p1v1[shape="record"; label="{B: 12|B: 10}"];
        p3v1[shape="record"; label="{D: 22|D: 20}"; style="invis"];
        p2v1[shape="record"; label="{A: 19|A: 15}"];
    
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-3.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {
  
     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 19\nB: 12"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
    }
    subgraph cluster_p2 {
      label = "Worker 2";
      subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        ls2[shape="cylinder" label = "D: 22"]
        d->ls2;
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        ls2->p3[dir="both"];
    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1[dir="back"];
        p1v1[shape="record"; label="{B: 12|B: 10}"];
        p3v1[shape="record"; label="{D: 22|D: 20}"];
        p2v1[shape="record"; label="{A: 19|A: 15}"];
    
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-4.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {
  
     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 21\nB: 13"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
    }
    subgraph cluster_p2 {
      label = "Worker 2";
      subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        ls2[shape="cylinder" label = "D: 23"]
        d->ls2;
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        ls2->p3[dir="both"];
    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1;
        p1v1[shape="record"; label="{B: 13|B: 12|B: 10}"];
        p3v1[shape="record"; label="{D: 23|D: 22|D: 20}"];
        p2v1[shape="record"; label="{A: 21|A: 19|A: 15}"];
    
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-5.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {
  
     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 21\nB: 13"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
    }
    subgraph cluster_p2 {
      label = "Worker 2";
      subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        ls2[shape="cylinder" label = "D: 23"]
        d->ls2;
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        ls2->p3[dir="both"];
    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1;
        p1v1[shape="record"; label="{B: 13}"];
        p3v1[shape="record"; label="{D: 23}"];
        p2v1[shape="record"; label="{A: 21}"];
    
  }
} 
-----

== Партиционирование и local state
[graphviz, "local-partitioning-6.png"]
-----
digraph D {
  graph [ dpi = 150 ]; 
  subgraph system {

     subgraph cluster_s2{
          style = "invis"
          S1 [shape=plaintext label = "Source"];
          S2 [shape=plaintext label = "Local store"];
          S3 [shape=plaintext label = "Changelog"];
          S1->S2->S3 [style="invis"]
      }

    subgraph cluster_p1 {
      label = "Worker 1";
        
        subgraph cluster_pp2{
              label = "Partition 3"
                
              d[label = "D"];
              
              
          }
          
          
        d->ls1;
        
        ls1->p3[dir="both"];
          
          subgraph cluster_pp11{
              label = "Partition 2"
          
              b [label = "B"];
              c[label = "C"];
              
          }
 
        subgraph cluster_pp1{
              label = "Partition 1"
              
              
              a [label = "A"];
              
          }
          
        
        ls1[shape="cylinder" label = "A: 21\nB: 13\nD: 23"]
        a->ls1;
        b->ls1;
        c->ls1;
        
        p1[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 2"];
        p2[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 3"];
        p3[shape="plaintext"; style="filled"; fillcolor="#ffffcc"; label = "Partition 1"];
        ls1->p1[dir="both"];
        ls1->p2[dir="both"];
        

    }
        p1->p1v1;
        p2->p2v1;
        p3->p3v1;
        p1v1[shape="record"; label="{B: 13}"];
        p2v1[shape="record"; label="{D: 23}"];
        p3v1[shape="record"; label="{A: 21}"];
  }
} 
-----


== Что ещё умеют стримы?

Соединять источники!

[graphviz, "join-storages.png"]
-----
digraph G {
graph [ dpi = 150 ]; 
rankdir="LR";
node [fontsize=18; shape="circle"; fixedsize="true"; width="1.1"];
Store1 [shape="cylinder"; label="Local Store 1"; fixedsize="true"; width="1.7"]
Store2 [shape="cylinder"; label="Local Store 2"; fixedsize="true"; width="1.7"]
Source1 -> Join
Source2 -> Join

Join -> Sink
Join -> Store1 [dir=both; label=" \n "]
Join -> Store2 [dir=both; label=" \n "]
Store1 -> Store2 [style=invis]
{rank = same; Store1; Join }

}
-----

== Агрегировать данные во временных окнах

.Источник: Kafka Streams in Action
image::tumbling-window.png[{image-70-width}]

== «Склеивать» данные, относящиеся к рабочей сессии

image::streams-session-windows-02.png[{image-50-width}]

== KSQL 


[source,sql]
----
CREATE STREAM pageviews_enriched AS
  SELECT pv.viewtime,
         pv.userid AS userid,
         pv.pageid,
         pv.timestring,
         u.gender,
         u.regionid,
         u.interests,
         u.contactinfo
  FROM pageviews_transformed pv
  LEFT JOIN users_5part u ON pv.userid = u.userid
  EMIT CHANGES;
----

== KSQL


[source,sql]
----
CREATE TABLE pageviews_per_region_per_30secs AS
  SELECT regionid,
         count(*)
  FROM pageviews_enriched
  WINDOW TUMBLING (SIZE 30 SECONDS)
  WHERE UCASE(gender)='FEMALE' AND LCASE(regionid)='region_6'
  GROUP BY regionid
  EMIT CHANGES;
----

== Кейсы для потоковых систем

* Мониторинг! Логи!
* Отслеживание действий пользователей
* Выявление аномалий (в т. ч. попыток мошенничества)

[%notitle]
== Всюду, где ценность/влияние данных уменьшается с их «возрастом»
image::streams-ok.svg[{image-90-width}]


[%notitle]
== Kafka -- это зацикленная плёнка
image::tapeloop.jpg[{image-70-width}]

[%notitle]
== Где использовать Kafka не очень удобно
image::streams-noway.svg[{image-90-width}]

== О чём следует помнить

* При изменении схемы данных миграция не похожа на RDBMS.
* Once-only delivery:
** В обычном режиме, сбой в KStreams приводит к повторному чтению данных.
** В режиме once-only delivery -- чтение и запись между топиками Kafka.

== Если нужно хранить данные всё время

* Лямбда-архитектура

[cols="30a,70a"]
|===
.^|image::nikita_salnikov.jpg[]
.^|
*Никита Сальников-Тарновский* https://2019.jokerconf.com/2019/talks/2qw2ljhlfoeiipjf0gfzzb/[Потоковое приложение — это не только код, но и 3-4 года поддержки в проде]
|===

== Наш план

[cols="20a,60a,20a"]
|===
.^|image::kafka.jpg[]
.^|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. [line-through]#Что такое потоковая архитектура и на что способны потоковые обработчики#
4. *Kafka и JavaScript*
5. Как попробовать Кафку сегодня
.^|image::kafka.jpg[]
|===

== Kafka и Javascript

[graphviz,streaming-arch2,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== Kafka и Javascript

[graphviz,streaming-arch3,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded,filled"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----

== kafka-node

image::kafka-node.png[]

* Лидер по звёздам и количеству использований
* Чистая JavaScript-реализация
* Умеет не всё.

== node-rdkafka

image::node-rdkafka.png[]

* Github-метрики проигрывают kafka-node
* JavaScript/C++
* Обёртка вокруг librdkafka -- очень зрелого проекта
* Умеет работать с Confluent Cloud


== Преобразующий/выходной каскад на node.js?

[graphviz,streaming-arch4,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier",shape="rectangle",style="rounded,filled"];
  Ledger2 [shape="record",label="{ | | | | }"];
  Caption2[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger2; Caption2;}
  D[label="In-memory\ndata store",shape="cylinder"];
  E[label="Data\naccess tier",shape="rectangle",style="rounded"];
  A->Ledger1->C->Ledger2->D->E;
  {rank = same; C; D;} 
}
----



== Преобразующий/выходной каскад на node.js?

[cols=2]
|===
a|image::nodefluent.png[]
a|
https://github.com/nodefluent[Nodefluent]

* node-sinek -- ещё один клиент
* kafka-streams -- реимплементация KStreams для node.js
* kafka-connect -- реимплементация kafka-connect
|===

== KSQL + Serverless

[graphviz,streaming-arch5,png]
----
digraph G {
  graph [ dpi = 190 ];
  rankdir="LR";
  A[label="Collection\ntier",shape="rectangle",style="rounded"];

  Ledger1 [shape="record",label="{ | | | | }"];
  Caption1[label="Log\n(Kafka)",shape="plaintext"];
  {rank = same; Ledger1; Caption1;}
  C[label="Analysis tier\n(KSQL)",shape="rectangle",style="rounded"];
 
  E[label="Consumer\n(serverless)",shape="rectangle",style="rounded,filled"];
  A->Ledger1->C->E;
}
----

https://www.confluent.io/kafka-summit-lon19/event-sourcing-stream-processing-serverless[Benjamin Stopford: Event Sourcing, Stream Processing and Serverless]

== Наш план

[cols="20a,60a,20a"]
|===
.^|image::kafka.jpg[]
.^|
1. [line-through]#Что такое лог и почему это важно#
2. [line-through]#Что такое Kafka и что она умеет#
3. [line-through]#Что такое потоковая архитектура и на что способны потоковые обработчики#
4. [line-through]#Kafka и JavaScript#
5. *Как попробовать Кафку сегодня*
.^|image::kafka.jpg[]
|===

== Вы решили попробовать Кафку. С чего начать?

https://kafka.apache.org/downloads

`kafkacat` -- лучший CLI инструмент

image::conduktor.png[]

Conduktor -- лучший GUI инструмент

== Conduktor

image::conduktor-screen.png[]

== Эксплуатировать Кафку в production тяжело

[cols="30a,70a"]
|===
.^|image::koshelev.jpg[]
.^|
*Григорий Кошелев*

* https://2019.jpoint.ru/talks/1xa5ea6p9djq1phnauiygm/[Когда всё пошло по Кафке]
* https://2019.devoops-piter.ru/2019/spb/talks/3cq28gbf1fzn40dpbq6bpu/[Как готовить Кафку, чтобы не пригорало]
|===








== Kafka: The Definitive Guide

[.custom-style]
[cols="30a,70a"]
|===
|image::kafka-the-definitive-guide.jpg[]
|
* Gwen Shapira, Neha Narkhede, Todd Palino
* September 2017
|===


== Сообщества, конференции
- Kafka Summit Conference: https://kafka-summit.org/

image::kafka-summit.png[]

== Телеграм

Грефневая Кафка

* https://t.me/AwesomeKafka_ru
* https://t.me/proKafka

== Митап в Москве 

Moscow Apache Kafka® Meetup by Confluent -- раз в квартал


